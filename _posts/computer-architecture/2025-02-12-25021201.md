---
title: "[Mano의 컴퓨터시스템구조] 명령어 코드"
excerpt: "명령어 코드, 컴퓨터 레지스터, 타이밍과 제어, 사이클, 입출력, 인터럽트, AC 레지스터, 가산 논리 회로"

categories:
  - Computer Architecture

toc: false
toc_sticky: false

date: 2025-02-12
last_modified_at: 2025-02-12
---

> 컴퓨터 구조 스터디를 하며 'Mano의 컴퓨터시스템구조 제3판' 교재를 정리한 글입니다.  

# 명령어 코드

컴퓨터가 특정 동작을 수행하도록 지시하는 비트들의 집합이다.  
연산 코드, 피연산자, 저장 정보 등 여러 부분으로 구성된다.  

## 연산 코드

덧셈, 시프트, 보수 등 동작을 정의하는 비트들의 집합이다.  
연산 코드가 $n$비트로 구성되면 $2^n$개의 서로 다른 연산을 실행할 수 있다.  

## 연산과 마이크로 연산

연산(operation)은 컴퓨터 메모리에 저장된 명령어의 일부로 특정 연산을 수행하도록 명령하는 이진 코드이다.  
마이크로 연산(microoperation)은 연산 실행을 위한 하드웨어 수준의 세부 동작이다.  
즉, 연산 코드는 마이크로 연산의 집합이다.  

## 저장 프로그램 구조

가장 간단한 컴퓨터의 구성으로 단일 프로세서 레지스터를 사용해 명령어 코드는 연산 코드, 주소로 구성한다.  
4096워드 메모리를 사용하고, 12비트 주소가 필요하다.  
명령어는 16비트로, 12비트는 메모리 주소, 4비트는 연산 코드이다.  

![51](/assets/images/25021201/51.png)  

메모리에서 명령어를 읽어 연산 코드, 주소를 해석한다.  
주소에 해당하는 피연산자를 찾아 누산기(AC)로 연산을 수행한다.  
일부 명령어(클리어, 보수, 인크리멘트 등)는 피연산자 없이 실행되며 5~16비트는 다른 목적으로 사용될 수 있다.  

## 간접 주소

immediate: 명령어 코드의 피연산자 주소 부분이 피연산자의 내용을 직접 나타냄  
직접 주소(direct address): 피연산자 내용이 담겨있는 메모리 주소를 나타냄  
간접 주소(indirect address): 주소의 내용을 담은 장소의 주소를 저장하고 있는 위치  
간접 주소 모드 비트($I$): 모드 비트가 0이면 직접 주소, 1이면 간접 주소  
유효 주소(effective address): 실행시 참조하는 실제 데이터가 저장된 주소  

![52](/assets/images/25021201/52.png)  

1. 직접 주소의 경우  
    - `ADD 457` : 주소 457에서 피연산자를 가져와 누산기에 더함  
    - 457이 유효 주소
2. 간접 주소의 경우
    - `ADD 300` : 주소 300에 1350이 저장되어 1350에서 피연산자를 가져와 연산 수행  
    - 메모리 참조 두 번 발생  
    - 1350이 유효 주소  

## 컴퓨터 레지스터

컴퓨터 명령어는 메모리에 저장되어 순차적으로 실행되는데, 다음 실행될 명령어 주소를 저장하는 카운터가 필요하다.  
그리고 데이터 저장 및 처리를 위한 레지스터(고속 저장 장치)가 필요하다.  

### 주요 레지스터와 종류

| 레지스터 | 비트 수 | 기능 |
|----------|--------|--------------------------------|
| DR (Data Register) | 16 | 메모리에서 읽어온 데이터 저장 |
| AR (Address Register) | 12 | 메모리 주소 저장 |
| AC (Accumulator) | 16 | 연산 결과 저장 |
| IR (Instruction Register) | 16 | 명령어 저장 |
| PC (Program Counter) | 12 | 다음 실행할 명령어 주소 저장 |
| TR (Temporary Register) | 16 | 임시 데이터 저장 |
| INPR (Input Register) | 8 | 입력된 문자 저장 |
| OUTR (Output Register) | 8 | 출력할 문자 저장 |

### 프로그램 카운터(PC)

PC 값이 순차적으로 증가하며 명령어를 하나씩 실행한다.  
명령어가 실행될 때 PC의 주소가 전달되어 다음 명령어를 가리킨다.  

### 공통 버스 시스템  

레지스터와 메모리 간 데이터 전송을 위한 경로를 제공한다.  
멀티플렉서와 3상태 버퍼 게이트를 사용해 하나의 공통 버스에서 동작한다.  
AC는 산술 및 논리 연산을 수행하는 레지스터로, DR 값과 AC 값을 연산해 AC에 저장한다.  

## 컴퓨터 명령어

연산 코드로 명령어 종류를 결정하고, 나머지 13비트는 기능 별로 다르게 사용된다.  

메모리 참조 명령어: 000~110, 주소 12비트를 사용하며, I비트가 존재   
레지스터 참조 명령어: 111, I=0, AC 레지스터 조작  
입출력 명령어: 111, I=0, 외부 장치와 AC 간 데이터 전송 수행   

### 주요 명령어 종류

| 명령어 | 16진 코드 ($I=0$) | 16진 코드 ($I=1$) | 설명 |
|--------|------------------|------------------|----------------------------|
| AND   | 0xxx | 8xxx | 메모리 값을 AC와 AND 연산 |
| ADD   | 1xxx | 9xxx | 메모리 값을 AC와 ADD 연산 |
| LDA   | 2xxx | Axxx | 메모리 값을 AC로 로드 |
| STA   | 3xxx | Bxxx | AC 값을 메모리에 저장 |
| BUN   | 4xxx | Cxxx | 무조건 분기 (Branch Unconditionally) |
| BSA   | 5xxx | Dxxx | 분기 및 반환 주소 저장 |
| ISZ   | 6xxx | Exxx | 값 증가 후 0이면 다음 명령어 건너뜀 |

| 명령어 | 16진 코드 | 설명 |
|--------|----------|----------------------------|
| CLA   | 7800 | AC 초기화 (Clear AC) |
| CLE   | 7400 | E 초기화 (Clear E) |
| CMA   | 7200 | AC 보수 (Complement AC) |
| CME   | 7100 | E 보수 (Complement E) |
| CIR   | 7080 | AC와 E 우측 순환 이동 (Circulate Right) |
| CIL   | 7040 | AC와 E 좌측 순환 이동 (Circulate Left) |
| INC   | 7020 | AC 증가 (Increment AC) |
| SPA   | 7010 | AC가 양수면 다음 명령어 건너뜀 |
| SNA   | 7008 | AC가 음수면 다음 명령어 건너뜀 |
| SZA   | 7004 | AC가 0이면 다음 명령어 건너뜀 |
| SZE   | 7002 | E가 0이면 다음 명령어 건너뜀 |
| HLT   | 7001 | 컴퓨터 정지 (Halt) |

| 명령어 | 16진 코드 | 설명 |
|--------|----------|----------------------------|
| INP   | F800 | 입력 문자를 AC에 저장 |
| OUT   | F400 | AC 값을 출력 |
| SKI   | F200 | 입력 플래그가 1이면 다음 명령어 건너뜀 |
| SKO   | F100 | 출력 플래그가 1이면 다음 명령어 건너뜀 |
| ION   | F080 | 인터럽트 활성화 |
| IOF   | F040 | 인터럽트 비활성화 |


### 명령어 집합의 완전성

컴퓨터는 사용자가 생각할 수 있는 모든 데이터 처리 작업을 수행할 수 있도록 충분한 명령어들을 갖고 있어야 한다.  

1. 산술, 논리, 시프트 명령어  
2. 메모리와 프로세서 레지스터 사이에 정보를 이동시킬 수 있는 명령어  
3. 상태 조건을 검사하는 명령과 프로그램 제어 명령어  
4. 입력과 출력 명령어  

## 타이밍과 제어

### 하드 와이어드(Hardwired) 제어 방식

게이트, 플립플롭, 디코더 등 하드웨어 회로를 이용하여 제어한다.  
속도가 빠르지만 구조 변경 시 하드웨어 수정이 필요하다.  

### 마이크로프로그램(Microprogrammed) 제어 방식

제어 메모리에 저장된 마이크로명령어를 이용하여 동작한다.  
구조 변경이 필요할 경우 마이크로 프로그램만 수정하면 된다.  

### 제어 장치 구성

디코더(Decoder), 순차 카운터(Sequence Counter), 제어 논리 게이트로 구성된다.  
명령어 레지스터(IR)의 3비트 연산 코드 부분을 디코더로 해석하여 실행할 명령어를 결정한다.  

순차 카운터(SC)가 동작하며 클럭 변화에 따라 타이밍 신호가 T0, T1, ... 순서대로 발생하는데, 타이밍 신호에 따라 제어 신호가 활성화된다.  
SC가 0일 때 T0에서 PC 값을 AR로 전송하고, PC의 값이 버스를 통해 AR로 전달된다.  
T1이면 다음 동작을 수행하고, T2, T3, T4를 순서대로 진행한 뒤 T4에서 명령 실행이 완료되면 SC가 0으로 초기화되며 T0으로 돌아간다.  

## 명령어 사이클

1. 명령어 가져오기 (Fetch)
2. 명령어 디코딩  
3. 간접 주소 방식의 경우 메모리에서 유효 주소를 읽음  
4. 명령어 실행  

## 메모리 참조 명령어

메모리에서 데이터를 읽거나 저장하는 7가지 명령어로 구성된다.  
명령어 디코더 출력에 따라 동작하며, 간접 주소 방식(I=1)일 경우 추가로 유효 주소를 먼저 읽는다.  

| 명령어 | 디코더 출력 | 연산 설명 |
|--------|------------|---------------------------------------------------------------|
| AND   | $D_0$ | $AC \gets AC \land M[AR]$ (AC와 메모리 데이터 AND) |
| ADD   | $D_1$ | $AC \gets AC + M[AR], E \gets C_{out}$ (덧셈 수행) |
| LDA   | $D_2$ | $AC \gets M[AR]$ (메모리 값 AC로 로드) |
| STA   | $D_3$ | $M[AR] \gets AC$ (AC 값 메모리에 저장) |
| BUN   | $D_4$ | $PC \gets AR$ (무조건 분기) |
| BSA   | $D_5$ | $M[AR] \gets PC, PC \gets AR + 1$ (서브루틴 호출) |
| ISZ   | $D_6$ | $M[AR] \gets M[AR] + 1, \text{ if } M[AR] = 0 \text{ then } PC \gets PC + 1$ (메모리 값 증가 후 0이면 다음 명령 건너뜀) |

## 입출력과 인터럽트

컴퓨터가 외부 장치(키보드, 프린터 등)와 통신하기 위해 입출력 장치를 사용하는데, 단말 장치(terminal device) 방식으로 입출력이 이루어진다.  

### 입출력 명령어

| 명령어 | 연산 설명 | 기능 설명 |
|--------|-----------------------------------------------|----------------------|
| $p$   | $SC \gets 0$ | SC 클리어 (Clear SC) |
| INP   | $pB_1 : AC(0-7) \gets INPR, FGI \gets 0$ | 입력 문자 (Input character) |
| OUT   | $pB_{10} : OUTR \gets AC(0-7), FGO \gets 0$ | 출력 문자 (Output character) |
| SKI   | $pB_9 : \text{If } (FGI=1) \text{ then } (PC \gets PC+1)$ | 입력 플래그가 1이면 건너뜀 (Skip on input flag) |
| SKO   | $pB_8 : \text{If } (FGO=1) \text{ then } (PC \gets PC+1)$ | 출력 플래그가 1이면 건너뜀 (Skip on output flag) |
| ION   | $pB_7 : IEN \gets 1$ | 인터럽트 활성화 (Interrupt enable on) |
| IOF   | $pB_6 : IEN \gets 0$ | 인터럽트 비활성화 (Interrupt enable off) |

### 프로그램 인터럽트

CPU가 입출력 장치를 지속적으로 확인하는 방식은 비효율적이므로, 인터럽트를 사용해 외부 장치가 CPU에 작업 완료 신호를 보낸다.  
인터럽트 활성화(IEN=1) 상태에서 FGI 또는 FGO가 1이면 인터럽트가 발생한 것이다.  

인터럽트 발생 시 현재 PC 값을 저장하고, PC를 인터럽트 서비스 루틴(ISR) 시작 주소로 변경한다.  
IEN과 R을 0으로 설정하고 새로운 인터럽트를 방지한다.  
인터럽트 서비스 루틴을 실행하고, 끝나면 ION(인터럽트 활성화) 명령을 실행해 IEN을 다시 1로 설정한다.  
BUN 명령으로 원래 실행 중이던 프로그램으로 복귀한다.  

## 기본 컴퓨터 설계

1. 16비트의 4096워드를 가진 메모리 장치  
2. 9개의 레지스터: AR, PC, DR, AC, IR, TR, OUTR, INPR, SC
3. 7개의 플립플롭: I, S, E, R, IEN, FGI, FGO
4. 2개의 디코더: $3 \times 8$ 동작 디코더와 $4 \times 16$ 타이밍 디코더  
5. 16비트 공통 버스
6. 제어 논리 게이트들
7.  AC의 입력에 연결된 가산 논리 회로  

## 누산기 논리 설계

![519](/assets/images/25021201/519.png)  

AC 레지스터는 연산 결과를 저장하는 주요 레지스터로, 가산 논리 회로와 연결되어 다양한 연산을 수행할 수 있다.  

### AC 레지스터에 대한 제어

![520](/assets/images/25021201/520.png)  

LD (Load): 여러 연산 결과를 AC에 저장, 연산 결과들이 OR 게이트로 AC에 전달됨  
INR (Increment): $r B_5$ 신호를 통해 AC 값 증가   
CLR (Clear): $r B_{11}$ 신호를 통해 AC 값을 0으로 초기화  
기타 연산에 대한 제어 신호는 각 논리게이트를 통해 LD, INR, CLR에 연결  

| 명령어   | 동작                                      | 설명           |
|---------|------------------------------------------|--------------|
| $D_0 T_5$  | $AC \leftarrow AC \land DR$            | $DR$과 AND |
| $D_1 T_5$  | $AC \leftarrow AC + DR$                | $DR$을 더함  |
| $D_2 T_5$  | $AC \leftarrow DR$                     | $DR$의 내용을 전송 |
| $p B_{11}$  | $AC(0-7) \leftarrow INPR$              | $INPR$의 내용을 전송 |
| $r B_9$   | $AC \leftarrow \overline{AC}$          | 보수 (Complement) |
| $r B_7$   | $AC \leftarrow shr AC, AC(15) \leftarrow E$ | 오른쪽 시프트 |
| $r B_6$   | $AC \leftarrow shl AC, AC(0) \leftarrow E$ | 왼쪽 시프트 |
| $r B_{11}$  | $AC \leftarrow 0$                      | 클리어 |
| $r B_5$   | $AC \leftarrow AC + 1$                 | 인크리먼트 |

### 가산 논리 회로

AC의 각 비트(16비트)에 대해 16개의 단(stage)로 나누어져 있다.  
레지스터 내부는 플립플롭과 논리 게이트로 구성되어 있다.  
16개의 입력 비트($I_i$)는 LD 입력이 인에이블될 때 $AC(0-15)$로 전송된다.  

![521](/assets/images/25021201/521.png)  

7개의 AND 게이트(연산 수행)와 1개의 OR 게이트(논리 결합), 1개의 전가산기(Full Adder, 덧셈 연산)로 구성되어 있다.  
위 그림 5-20에서 가져온 연산 신호와 연결되어 AND 게이트 입력에 따라 $AC(i)$ 값이 조정된다.  

