---
title: "[운영체제 공룡책] 메인 메모리"
excerpt: "연속 메모리 할당과 단편화, 페이징,"

categories:
  - Operating System

toc: false
toc_sticky: false

date: 2025-07-24
last_modified_at: 2025-07-25
---

> 운영체제 스터디를 하며 '운영체제 공룡책' 교재를 정리한 글입니다.  

# 메인 메모리

메모리는 주소가 할당된 바이트들로 구성된다.  
CPU는 PC가 지시하는 대로 메모리에서 다음에 수행할 명령어를 가져온다.  
명령어를 해독하고, 메모리에서 피연산자(operand)를 가져와 피연산자에 대해 명령어를 실행한 후 계산 결과를 메모리에 저장한다.  
메모리는 주소에 지시한 대로 읽기, 쓰기만 할 뿐 주소가 어떻게 생성됐는지나 가리키는 내용이 무엇인지는 모른다.  

## 개요

### 기본 하드웨어

CPU는 메모리에 직접 접근하지 못하므로, 메모리에서 레지스터로 옮긴 뒤 처리해야 한다.  
각 CPU 코어에 내장된 레지스터들은 일반적으로 CPU 클록(clock)의 1사이클(cycle)내에 접근이 가능하다.  
메인 메모리는 레지스터보다 느려서 여러 클록 틱(tick)이 필요하고, 이때 CPU는 필요한 데이터가 없어서 명령어를 수행하지 못하고 지연되는(stall) 현상이 발생한다.  
이러한 문제를 해결하기 위해 CPU와 메인 메모리 사이에서 캐시를 사용한다.  

시스템이 올바르게 동작하기 위해서는 사용자 프로그램으로부터 운영체제 영역을 보호하고, 사용자 프로그램 사이도 서로 보호해야 한다.  
따라서 각각의 프로세스가 독립된 메모리 공간을 가져야 한다.  
이를 기준(base) 레지스터와 상한(limit) 레지스터를 사용하여 보호한다.  
기준 레지스터는 가장 작은 합법적인 물리 메모리 주소 값을 저장하고, 상한 레지스터는 주어진 영역의 크기를 저장한다.  
기준 레지스터 값이 300040이고, 상한 레지스터 값이 120900이라면, 프로그램은 300040에서 420940까지 주소에 접근할 수 있다.  
접근 범위를 벗어난다면 치명적인 오류로 간주하고 트랩(trap)을 발생시킨다.  
기준, 상한 레지스터는 운영체제의 여러 특권 명령(special privileged instruction)에 의해서만 적재된다.  

### 주소 할당

프로그램을 실행하는 것은 먼저 소스 프로그램을 작성하고, 컴파일러가 소스를 오브젝트 파일로 변환(컴파일 시간)한 다음, 링커가 여러 오브젝트 파일을 묶어 실행 파일을 생성(적재 시간)하면, 로더가 실행 파일을 메모리에 올려(실행 시간) CPU가 명령어와 데이터에 엑세스하는 과정으로 진행된다.  

전통적으로 메모리 주소 공간에서 명령어와 데이터 바인딩은 바인딩이 이루어지는 시점에 따라 구분한다.  

- 컴파일 시간(compile time) 바인딩: 컴파일 시간에 프로세스의 메모리 위치를 알 수 있다면 절대 코드를 생성할 수 있다. 주소가 변경되면 다시 컴파일해야 한다.  
- 적재 시간(load time) 바인딩: 컴파일 시점에 프로세스 메모리 내 어디로 올라와야할 지 모른다면 이를 재배치 가능 코드로 만들어 메인 메모리에 실제 적재할 때 메모리 위치가 정해진다.  
- 실행 시간(execution time) 바인딩: 실행 중간에 메모리 내 세그먼트 간 이동과 같은 주소 변경이 발생할 수 있다.  

### 논리 주소 vs 물리 주소

논리 주소(logical address)는 CPU가 생성하는 주소로 프로그램 입장에서의 주소이고, 물리 주소는(physical address)는 메모리가 취급하게 되는 주소로 실제 메모리의 위치이다.  
런타임 바인딩 기법에서는 논리 주소와 물리 주소가 다르며, 논리 주소를 가상 주소라고 한다.  
프로그램에 의해 생성된 논리 주소 집합을 논리 주소 공간(logical address space)이라 하고, 이 논리 주소와 일치하는 모든 물리 주소 집합으로 물리 주소 공간(physical address space)이라고 한다.  

메모리 관리 장치(memory management unit, MMU)는 프로그램 실행 중에 가상 주소를 물리 주소로 바꿔주는 하드웨어 장치이다.  
재배치 레지스터(relocation)는 논리 주소에 더해지는 고정값이다.  
재배치 레지스터 값이 14000일 때, 프로세스가 346번지에 액세스하고자 하면 메인 메모리의 14346번지에 액세스하게 된다.  

이를 통해 사용자 프로그램은 항상 0부터 시작하는 것처럼 자겅할 수 있으며, 실제 메모리 주소는 실행 시간에 결정되므로 동적 메모리 배치가 가능하다.  
사용자 프로그램이 실제 물리 주소를 알 수 없어 보안 및 안전성이 향상된다.  

### 동적 적재

메모리 공간을 효율적으로 사용하기 위해서는 동적 적재(dynamic loading)가 필요하다.  
동적 적재 시 각 루틴이 실제 호출되기 전까지 메모리에 올라오지 않고 재배치 가능한 상태로 디스크에서 대기한다.  
main 프로그램이 먼저 메모리에 올라와 실행되면, 이 루틴이 다른 루틴을 호출할 때 이미 적재된 루틴인지 확인하여 적재되어 있지 않다면 재배치 가능 연결 적재기(relocatable linking load-er)가 루틴을 메모리로 가져와 테이블에 기록한다.  

동적 적재를 통해 루틴이 필요할 때만 적재하여 전체 프로그램의 크기가 크더라도 실제로 적재하는 부분을 이보다 작게 유지할 수 있다.  

### 동적 연결 및 공유 라이브러리(DLL)

사용자 프로그램이 실행될 때 사용자 프로그램에 연결되는 시스템 라이브러리이다.  
프로그램이 동적 라이브러리에 있는 루틴을 참조하면 로더가 DLL을 찾아 필요한 경우 메모리에 적재한다.  
동적 연결을 통해 연결(linking)이 실행 시기까지 미루어지게 할 수 있고, 여러 프로세스 간 공유하도록 할 수 있다.  
주로 표준 C언어 라이브러리와 같은 시스템 라이브러리에 사용되며, 공유 라이브러리로서 Windows 및 Linux 시스템에서 광범위하게 사용된다.  

## 연속 메모리 할당

메모리는 일반적으로 운영체제를 위한 부분과 사용자 프로세스를 위한 부분으로 나뉜다.  
대부분의 운영체제는 운영체제를 높은 메모리에 배치한다.  
연속 메모리 할당에서 각 프로세스는 다음 프로세스가 적재된 영역과 인접한 메모리 영역에 적재된다.  

### 메모리 보호

프로세스가 자신이 소유하지 않은 메모리에 접근할 수 없도록 해야 한다.  
재배치 레지스터와 상한 레지스터를 통해 이를 해결할 수 있다.  
CPU 스케줄러가 다음에 실행할 프로세스를 선택할 때, 디스패처(dispatcher)가 컨텍스트 스위칭 과정 중 하나로 재배치 레지스터와 상한 레지스터에 정확한 값을 적재한다.  

### 메모리 할당

메모리를 할당하는 가장 간단한 방법은 프로세스를 메모리의 가변 크기 파티션에 할당하는 가변 파티션 기법이다.  
운영체제는 사용 가능한 부분과 사용 중인 부분을 나타내는 테이블을 유지하는데, 이 때 사용 중인 부분들 사이에는 큰 사용 가능한 메모리 블록인 hole 이 생긴다.  

이때 동적 메모리 할당 문제(dynamic storage allocation problem)가 발생한다.  
일련의 가용 공간 리스트에서 크기 n-바이트 블록을 요구할 때 어떻게 만족시켜줄 것이냐를 결정하는 문제이다.  

- 최초 적합(first-fit): 집합의 시작, 지난번 검색이 끝난 곳 등 검색의 시작부터 첫 번째 사용 가능한 가용 공간을 할당한다.  
- 최적 적합(best-fit): 사용 가능 공간 중 가장 작은 것을 선택한다. 리스트가 크기 순이 아니라면 모든 리스트를 검색해야 한다.  
- 최악 적합(worst-fit): 가장 큰 가용 공간을 선택한다.  

최초 적합과 최적 적합 모두 시간, 메모리 이용 효율이 최악 적합보다 좋다.  
그리고 일반적으로 최초 적합이 최적 적합보다 빠르다.  

### 단편화(Fragmentation)

최초 적합과 최적 적합 전략은 외부 단편화(external fragmentation) 문제가 발생한다.  
프로세스를 메모리에 적재하고 제거하는 일을 반복하다 보면 메모리들이 많은 수의 매우 작은 조각들로 단편화될 수 있다.  
프로세스 사이마다 못 쓰는 가용 공간을 많이 가지게 되면 이 공간을 합쳐 하나의 큰 가용 공간으로 만들 수 있다.  

이때 압축(compction)이라는 방법을 사용하여 메모리 모든 내용을 한군데로 몰고 가용 공간을 다른 한군데로 몰아서 큰 블록을 만들 수 있다.  
그러나 재배치가 어셈블 또는 적재 시 정적으로 행해지면 압축은 실행할 수 없고, 프로세스의 재배치가 실행 시간에 동적으로 이루어질 때만 가능하다.  
압축이 가능하더라도 프로세스를 한 쪽에 몰고 가용 공간을 다른 한쪽으로 모는 과정은 비용이 매우 많이 든다.  

보통 메모리는 아주 작은 사이즈의 여러 블록으로 나누어 프로세스가 필요한 만큼의 개수를 할당한다.  
그렇다면 프로세스의 크기가 블록과 정확히 일치하지 않을 때, 프로세스에 할당한 블록 내부에 남는 공간이 생길 수 있다.  
이렇게 남는 공간을 내부 단편화(internal fragmentation)이라고 한다.  

## 페이징


