---
title: "[운영체제 공룡책] 교착 상태"
excerpt: "교착 상태 예방, 회피, 탐지"

categories:
  - Operating System

toc: false
toc_sticky: false

date: 2025-07-08
last_modified_at: 2025-07-15
---

> 운영체제 스터디를 하며 '운영체제 공룡책' 교재를 정리한 글입니다.  

# 교착 상태

Mutex 락, 세마포 등 동기화 도구들은 시스템 자원으로 현대 컴퓨터 시스템에서의 교착 상태 발원지이다.  
락은 일반적으로 큐에 대한 액세스를 보호하거나 연결 리스트에 대한 액세스를 보호하는데 사용되는 등 특정 자료구조와 연관되어 있다.  
스레드는 자원을 사용하기 전에 반드시 요청해야 하고, 사용 후에 반드시 방출해야 한다.  

1. 요청: 스레드가 자원을 요청, 요청이 혀용되지 않으면 자원을 얻을 때까지 대기
2. 사용: 스레드가 자원에 대한 작업 수행
3. 방출: 스레드가 자원 방출

자원의 요청과 방출은 장치의 request(), release(), 파일의 open(), close(), 메모리 시스템 콜 allocate()와 free()  등이 있다.  
세마포의 획득과 방출은 wait(), signal() 연산, mutex 락의 획득과 방출은 acquire(), release()를 통해 이루어진다.  

운영체제는 스레드가 커널이 관리하는 자원을 사용할 때마다 스레드가 자원을 요청했는지, 할당 받았는지를 확인한다.  
시스템 테이블은 각 자원이 가용 상태인지 할당되었는지, 어느 스레드에 할당되었는지 기록한다.  

한 스레드 집합 내의 모든 스레드가 그 집합 내의 다른 스레드에 의해 발생될 수 있는 이벤트를 기다린다면 이 스레드 집합은 교착 상태에 있게 된다.  

## 다중 스레드 애플리케이션의 교착 상태

스레드 두 개(`thread_one`, `thread_two`)와 mutex 락 두 개(`first_mutex`, `second_mutex`)가 있다고 가정하자.  
`thread_one`이 1) `first_mutex` 2) `second_mutex` 순서대로 락을 획득하려고 한다.  
`thread_two`가 1) `second_mutex` 2) `first_mutex` 순서대로 락을 획득하려고 한다.  
이 때 `thread_one`이 `first_mutex` 를 획득하고 `thread_two`가 `second_mutex` 를 획득하면 교착 상태가 발생한다.  
하지만 `thread_two`가 `first_mutex` 락 획득을 시도하기 전에 `thread_one`이 `first_mutex` 를 방출한다면 교착 상태는 발생하지 않는다.  

### 라이브락(Livelock)

라이브락은 교착 상태와 유사하지만 일반적으로 스레드가 실패한 작업을 동시에 재시도할 때 발생한다.  
따라서 각 스레드가 실패한 행동을 재시도하는 시간을 무작위로 정하면 회피할 수 있다.  
네트워크 충돌이 발생할 때 Ethernet 네트워크의 접근법과 동일하다.  

## 교착 상태 특성

### 필요조건

한 시스템에서 아래 네 가지 조건이 동시에 성립할 때 발생한다.  

1. 상호배제(mutual exclusion): 한 번에 한 스레드만 사용할 수 있는 자원이 하나 이상 점유된다.  
2. 점유하며 대기(hold-and-wait): 스레드가 최소 하나의 자원을 점유하고 다른 스레드에 점유된 자원을 추가로 얻기 위해 대기한다.  
3. 비선점(no preemption): 자원을 강제로 방출할 수 없다.  
4. 순환 대기(circular wait): 대기하고 있는 스레드의 집합에서 다음 스레드가 요구하는 자원을 순환적으로 점유하고 있다.  

### 자원 할당 그래프

자원 할당 그래프는 교착 상태를 정확하게 기술할 수 있는 방향 그래프이다.  

이 그래프가 사이클을 포함하지 않으면 시스템 내 어느 스레드도 교착 상태가 아니게 된다.  
반대로 사이클을 포함한다면 교착 상태가 존재할 수 있다.  
사이클이 각각 하나의 인스턴스만 갖는 자원을 포함한다면 교착 상태가 발생한다.  
만약 각 자원 유형이 여러개의 인스턴스를 가지면 반드시 교착 상태가 발생하지는 않는다.  

## 교착 상태 처리 방법

원칙적으로 교착 상태를 처리하기 위한 방법 3가지가 있다.  

1. 문제를 무시하고 교착 상태가 시스템에 절대 발생하지 않는 척 한다.  
2. 시스템이 교착 상태가 되지 않게 보장하기 위해 교착 상태를 예방하거나 회피하는 프로토콜을 사용한다.  
3. 교착 상태를 허용한 뒤 복구시킨다.  

Linux, Windows를 포함해 대부분의 운영체제가 첫 번째 해결안을 사용한다.  
따라서 응용 개발자가 2번 방식으로 교착 상태를 처리할 수 있게 한다.  
데이터베이스와 같은 일부 시스템은 3번째 방식을 주로 사용한다.  

## 교착 상태 예방

### 상호 배제

공유 가능 자원들은 배타적인 접근을 요구하지 않으므로 교착 상태와 관련될 수 없다.  
읽기 전용 파일은 동시 접근을 하용하므로 프로세스가 공유 가능 자원을 위해 대기할 필요가 없다.  
그러나 일반적으로 동시에 여러 스레드가 공유할 수 없는 mutex 락과 같은 상황에서 상호 배제 조건을 거부하여 교착 상태를 예방하기는 어렵다.  

### 점유하며 대기

스레드가 자원을 요청할 때마다 다른 자원을 보유하지 않아야 한다.  
따라서 스레드가 자원을 가지고 있지 않을 때만 자원을 요청할 수 있도록 해야 한다.  
혹은 스레드가 일부 자원을 요청하여 사용할 수 있게 하고, 추가로 자원을 요청하려면 할당된 자원을 모두 방출하게 한다.  

자원이 할당되고 오래 사용되지 않을 수 있어 자원 이용률이 낮을 수 있다.  
또는 인기 있는 자원이 여러개 필요한 스레드가 자원에 접근할 수 없어 무한정 대기해야 할 수 있다.  

### 비선점

이미 할당된 자원이 선점되지 않게 해야 한다.  

만약 스레드가 필요한 자원을 다른 스레드가 보유하고 있다면, 현재 자원을 사용하는 스레드가 자원을 방출할 때까지 기다려야 한다.  
그리고 자원을 요청한 스레드는 자원을 사용할 수 있을 때까지 대기 상태가 된다.  

어떤 스레드 A가 자원을 요청했을 때, 그 자원을 어떠한 스레드 B가 사용하고 있다면, 자원을 가진 스레드 B가 다른 자원을 위해 대기 중인지 확인한다.  
만약 대기 상태에 있다면, 자원을 요청한 스레드 A에게 할당한다.  

CPU 레지스터, 데이터베이스 트랜잭션과 같이 상태가 쉽게 저장되고 복원될 수 있는 자원에 종종 적용된다.  
mutex 락, 세마포에는 적용하기 어렵다.  

### 순환 대기

위 세가지 방식은 일반적으로 실용적이지 않아, 순환 대기 조건을 무효화하여 해결하는 것이 실용적이다.  
모든 자원에 순서를 부여해 각 프로세스가 열거된 순서대로 자원을 요청하도록 한다.  
`first_mutex`, `second_mutex` 가 동시에 필요한 스레드가 있다면, 반드시 `first_mutex`를 먼저 요청하고 `second_mutex`를 요청할 수 있다.  

## 교착 상태 회피

교착 상태 회피는 교착 상태가 생기지 않도록 시스템이 상황을 예측해서 자원 할당을 제어하는 것이다.  
어떤 자원이 얼마나 있고, 누가 어떤 자원을 가지고 있는지, 얼마나 요청할지 등의 정보를 알아야 한다.  
시스템이 자원의 상태를 미리 분석해 교착 상태가 생길 위험이 있으면 자원의 요청을 거절한다.  

### 안전 상태

안전 상태는 시스템이 어떤 순서로든 스레드들이 요청하는 모든 자원을 교착 상태를 발생시키지 않고 모두 할당해줄 수 있다는 것이다.  
시스템이 안전 순서(safe sequence)를 찾을 수 있으면 안전하다고 말한다.  
스레드들이 자원을 요청하는 순서가 T1 → T0 → T2 처럼 존재하고, 이 순서대로 자원을 줄 수 있다면 안전한 상태이다.  

시스템의 상태가 안전하면 교착상태가 아니다.  
교착 상태의 시스템은 불안전한 상태에 있으며, 시스템 상태가 불안전하다고 해서 반드시 교착상태로 간다는 것은 아니다.  

### 자원 할당 그래프 알고리즘

자원 할당 그래프에 예약 간선(claim edge)를 도입할 수 있다.  
미래에 자원을 요청한다는 의미이며, 점선으로 표시한다.  
스레드가 실제로 자원을 요청하면 요청 간선으로 바뀌고, 자원을 방출하면 다시 예약 간선으로 바뀐다.  

사이클 탐지(cycle detection) 알고리즘을 이용해 안전성을 검사한다.  
사이클이 발견되면 자원 할당 시 시스템이 불안전 상태가 되므로, 사이클이 없을 때 자원을 할당한다.  

### 은행원 알고리즘(Banker's Algorithm)

이 알고리즘은 고객들이 현금을 찾으러 왔을 때 일정한 순서에 의해 모든 고객의 다 요청을 들어줄 수 있는 알고리즘이다.  
스레드가 시작할 때 스레드가 가지고 있어야 할 자원의 최대 개수를 자원마다 미리 신고해야 한다.  

이를 구현하기 위해 4가지의 자료구조가 필요하다.  

- Available: 현재 사용 가능한 자원 개수  
- Max: 각 스레드가 최대로 필요로 하는 자원의 수   
- Allocation: 각 스레드에 현재 할당된 자원의 수  
- Need: 각 스레드가 앞으로 더 요청할 수 있는 자원의 수  

**안전성 알고리즘**  

시스템이 안전한지를 알아낼 수 있는 알고리즘이다.  
$m × n^2$ 연산($m$: 자원 종류 수, $n$: 스레드 수)이 필요하다.  

`Work`: 현재 사용 가능한 자원  
`Finish[i]`: 각 스레드가 완료되었는지   

1. `Work` 를 `Available` 로 , `Finish[i] = False` 로 초기화한다.  
2. `Finish[i] = False` 이며 `Need[i] ≤ Work` 인 `i` 값을 찾는다. 찾을 수 없으면 4번으로 간다.  
3. `Work = Work + Allocation[i]`, `Finish[i] = true` 후 2번으로 간다.  
4. 모든 `i` 값에 대해 `Finish[i] == true` 이면 시스템이 안전 상태이다.  

**자원 요청 알고리즘**  

자원 요청을 안전하게 수락할 수 있는지 확인하는 알고리즘이다.  
어떤 프로세스 Tᵢ가 자원 Request[i]를 요청했을 때, 아래 3단계를 따라간다.  

1. `Request[i] ≤ Need[i]` 이면 2번으로 간다. 아니라면 시스템에 있는 개수보다 많이 요청했으므로 오류로 처리한다.  
2. `Request[i] ≤ Available` 이면 3번으로 간다. 아니면 요청한 자원이 현재는 없어 기다려야 한다.  
3. 자원을 실제로 할당한 것처럼 상태를 바꾸고, 안정성 알고리즘을 통해 시스템이 안전한 상태인지 확인한다.  
- 만약 바뀐 상태가 안전하면 자원을 할당하고, 불안전하다면 자원 할당 상태를 원래대로 복원한다.  

```C
Available  = Available - Request[i]
Allocation[i] = Allocation[i] + Request[i]
Need[i]       = Need[i] - Request[i]
```

## 교착 상태 탐지



