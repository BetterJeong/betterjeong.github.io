---
title: "[운영체제 공룡책] 모니터, 라이브니스"
excerpt: "동기화 도구들, 세마포를 활용한 모니터 구현, 교착 상태, 우선순위 역전"

categories:
  - Operating System

toc: false
toc_sticky: false

date: 2025-07-01
last_modified_at: 2025-07-01
---

> 운영체제 스터디를 하며 '운영체제 공룡책' 교재를 정리한 글입니다.  

# 동기화 도구들

## 모니터(Monitors)

세마포 혹은 mutex 락을 사용할 때 프로그래머가 잘못 사용한다면 오류가 쉽게 발생할 수 있다.  
간단한 동기화 기법을 통해 고급 언어 차원의 추상화 도구를 제공하여 처리할 수 있다.  

### 모니터 사용법

추상 자료형(abstract data type, ADT)은 데이터와 데이터를 조작하는 함수들을 하나로 묶어 보호한다.  
모니터 형은 모니터 내부에서 상호 배제가 보장되도록 설계된 ADT이다.  

모니터 안에 항상 하나의 프로그램만 활성화되도록 보장한다.  
모니터 내부에 정의된 함수는 해당 모니터 내부에서만 사용 가능하며, 다른 프로세스가 접근할 수 없다.  
모니터 내부에서 선언된 변수도 모니터 내 함수나 형식 매개변수로만 접근할 수 있다.  
따라서 한 번에 하나의 스레드만 모니터 안의 함수를 실행할 수 있다.  

`condition` 구조체를 사용하여 프로세스가 기다리게 하거나 프로세스를 깨울 수 있다.  
`condition` 형 변수에서는 `wait()`과 `signal()`을 호출할 수 있다.  

```C
condition x, y;
```

`x.wait()`: 조건 `x` 가 만족될 때까지 기다리고, 현재 프로세스는 일시 정지 상태가 됨  
`x.signal()`: 조건 `x`를 기다리는 프로세스 중 하나를 깨움  

모니터 외부에서 프로세스들이 진입 큐에 대기하고 있다가 하나씩 들어와서 실행한다.  
내부에서 `x.wait()` 호출을 하면 조건 `x`와 관련된 큐는 일시정지된다.  
`x.signal()` 호출이 발생하면 Signal and wait 방식 또는 Signal and continue 방식 중 하나로 실행이 재개된다.  
따라서 모니터 내부에 동시에 실행되는 스레드는 하나로 유지된다.  

- Signal and wait: signal을 보낸 스레드가 나가고, 대기하던 스레드를 실행  
- Signal and continue: signal을 보낸 스레드를 계속 실행하고, 나중에 대기하던 스레드를 실행  

### 세마포를 활용한 모니터 구현

```C
wait(mutex);
    ...
    body of F
    ...
if (next_count > 0)
    signal(next);
else
    signal(mutex);
```

모니터마다 mutex라는 이진 세마포를 정의하고 초기 값을 1로 설정한다.  
프로세스가 모니터로 들어가기 전에 `wait(mutex)` 를 실행하고, 모니터를 나온 후에 `signal(mutex)`를 실행한다.  
모니터는 signal-and-wait 기법을 사용한다. 
signal을 호출하는 프로세스는 자신을 기다리도록 하기 위해 `next` 라는 이진 세마포가 추가로 필요하며, `next` 는 0으로 초기화한다.  

조건 변수를 세마포로 구현할 때 각 조건 `x` 마다 `x_sem` 이라는 이진 세마포와 `x_count` 라는 정수형 변수를 선언하고 0으로 초기화한다.  

```C
// x.wait() 연산
x_count++;
if (next_count > 0)
    signal(next);
else 
    signal(mutex);
wait(x_sem);
x_count--;
```

```C
// x.signal() 연산
if (x_count > 0) {
    next_count++;
    signal(x_sem);
    wait(next);
    next_count--;
}
```

### 모니터 내에서 프로세스 수행 재개

조건 변수에 여러 프로세스가 일시 중지 되어 있을 때 `signal()` 연산을 수행하면, 일시 중지 되어 있던 프로세스 중 어떤 프로세스를 재개할 것인가에 대한 문제이다.  

conditional-wait 방식을 사용할 수 있다.  

```C
x.wait(c);
```

여기서 `c`는 정수 수식(expression)으로, `wait()` 연산 호출 시 값이 계산된다.  
`c`의 값은 우선순위 번호(priority number)로 불리며 일시 중지 되는 프로세스 이름과 함께 저장된다.  
`signal()` 호출 시 가장 작은 우선순위 번호를 가진 프로세스가 다음번에 수행 재개 된다.  

## 라이브니스

프로세스가 실행 수명주기 동안 진행되는 것을 보장하기 위해 시스템이 충족해야하는 속성이다.  
무기한 대기하는 프로세스와 같은 경우는 라이브니스 실패의 예시이다.  

### 교착 상태(Deadlock)

두 개 이상의 프로세스들이 대기 중인 프로세스 중 하나에 의해 실행되는 이벤트를 무한정 기다리는 상황을 의미한다.  
한 집합 내의 모든 프로세스가 그 집합 내에 다른 프로세스만이 유발할 수 있는 이벤트를 기다릴 때, 이 프로세스의 집합이 교착 상태에 있다고 말한다.  

### 우선순위 역전(Prioirity Inversion)

우선순위가 높은 작업이 우선순위가 낮은 작업이 쓰고 있는 자원을 기다릴 때 실행이 지연되는 현상을 말한다.  
공유 자원에 lock이 걸려 있을 때, 낮은 우선 순위 프로세스가 높은 우선순위 프로세스에 양보하지 않고 계속 실행한다면 높은 우선순위 프로세스가 계속 대기하게 된다.  
보통 셋 이상의 우선순위를 가진 시스템에서만 발생한다.  

우선순위 상속 프로토콜(priority-inheritance protocol)을 구현하여 해결할 수 있다.  
더 높은 우선순위 프로세스가 필요로 하는 자원에 접근하는 모든 프로세스는 문제가 된 자원의 사용이 끝날 때까지 더 높은 우선순위를 상속받는다.  
따라서 우선순위가 낮은 프로세스는 빠르게 실행되어 자원을 빨리 놓을 수 있게 된다.  
